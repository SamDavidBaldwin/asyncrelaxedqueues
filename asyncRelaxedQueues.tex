\documentclass[a4paper,USenglish]{lipics-v2021} % TODO: Re-add anonymous tag

\usepackage{algorithm,algpseudocode}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Relaxation for Efficient Asynchronous Queues}

\titlerunning{Asynchronous Relaxed Queues}

\author{Samuel Baldwin}{Bucknell University, USA}{}{https://orcid.org/0000-0002-1825-0097}{}

\author{Cole Hausman}{Bucknell University, USA}{}{[orcid]}{}

\author{Mohamed Bakr}{Bucknell University, USA}{}{ORCID}{}

\author{Edward Talmage}{Bucknell Univserity, USA}{elt006@bucknell.edu}{ORCID}{}

\authorrunning{S. Baldwin, C. Hausman, M. Bakr, E. Talmage} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Samuel Baldwin, Cole Hausman, Mohamed Bakr, Edward Talmage} 

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Distributed Data Structures, Asynchronous Algorithms, Relaxed Data Types} %TODO mandatory; please add comma-separated list of keywords

\funding{Funding provided by Bucknell University}

%\acknowledgements{I want to thank \dots}%optional

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
\maketitle

%%%%%%%%%%%%%%%
\section{Introduction}

%%%%%%%%%%%%%%%
\subsection{Related Work}

%%%%%%%%%%%%%%%
\section{Model and Definitions}

%%%%%%%%%%%%%%%
\subsection{Queue Definitions}

%%%%%%%%%%%%%%%
\section{Asynchronous FIFO Queues}

%%%%%%%%%%%%%%%
\subsection{Description}

%%%%%%%%%%%%%%%
\subsection{Algorithm}

%%%%%%%%%%%%%%%
\subsection{Correctness}

%%%%%%%%%%%%%%%
\subsection{Complexity}

%%%%%%%%%%%%%%%
\section{Asynchronous Out-of-Order Queues}

%%%%%%%%%%%%%%%
\subsection{Description}

%%%%%%%%%%%%%%%
\subsection{Algorithm}

\begin{algorithm}
  \caption{Code for each process $p_i$ to implement a Queue with out-of-order k-relaxed \textit{Dequeue}, where $k \geq n$ and $l = [k/n]$}
  \begin{algorithmic}[1]
    \Function{Enqueue}{$val$}
      \State $EnqCount = 0$
      \State $updateTS(v_i)$
      \State $enq\_timestamp = v_i$
      \State send $(EnqReq, val, i, enq\_timestamp)$ to all processes
    \EndFunction

    \Function{Receive}{$EnqReq, val, j, enq\_timestamp$} from $p_j$
      \State $updateTS(v_i, v_j)$
      \If {$enq\_timestamp$ not in Pending\_Enqueues}
        \State $Pending\_Enqueues.insertByTS(enq\_timestamp, val)$
      \EndIf

      \State send $(EnqAck, i)$ to $p_j$
    \EndFunction

    \Function{Receive}{$EnqAck$ from $p_j$}
      \State $EnqCount += 1$
      \If {$EnqCount == n$} 
        \If {$localQueue.size < k$}
          \State send $(EnqConfirm, enq\_timestamp)$ to all processes
        \EndIf
      \EndIf

      \State \Return $EnqResponse$
    \EndFunction

    \Function{Receive}{$EnqConfirm, enq\_timestamp$ from $p_j$} 
      \State $localQueue.insertByTS(Pending\_Enqueues.getByTS(enq\_timestamp))$
      %\boxit{yellow}{3}
      \If {$clean == true$ and $localQueue.size() \leq k$} \Comment{localQueues agree by this point}
        \State let $procNum = (localQueue.size() -1 \mod n$
        \State $localQueue.label(p_{procNum}, localQueue.tail)$\Comment{I may have mangled this line}
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Continued, part 2}
  \begin{algorithmic}[1]
    \Function{Dequeue}{}
      \State $v_i += 1$
      \State let $Deq_{ts} = v_i$
      \If {$localQueue.peekByLabel(p_{i}) \neq \bot$} \Comment{Check that I didn't change this}
        \State let $ret = localQueue.deqByLabel(p_i)$
        \State send $(Deq_f, ret, Deq_{ts})$ to all processes
      \Else
        \State send $(Deq_s, null, Deq_{ts})$ to all processes
      \EndIf
    \EndFunction

    \Function{Receive}{$deq_f, val, Deq_{ts})$ from $p_j$}
      \If {$j \neq i$} $localQueue.remove(val)$ \EndIf
    \EndFunction

    \Function{Receive}{$deq_s, val, Deq_{ts}$ from $p_j$}
      \State $UpdateTs(v_i, Deq_{ts})$

      \If{$Deq_{ts}$ is not in $PendingDequeues$}
        \State $PendingDequeues.insertByTs(createList(Deq_{ts}, p_{invoker}$)) \Comment{Check line}
      \EndIf

      \State let $p_{invoker} = p_j$ \Comment{This doesn't make sense to me? What are you doing on this line?}
      \If{$Deq_{ts} \neq 0$ and $Deq_{ts} < v_i$}
        \State send $(Unsafe, Deq_{ts}, i, p_{invoker})$ to all processes
      \Else
        \State send $(Safe, Deq_{ts}, i, p_{invoker})$ to all processes
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Continued, part 3}
  \begin{algorithmic}[1]
    \Function{Receive}{$Safe/Unsafe, Deq_{ts}, j, p_{invoker}$}
      \If{$Deq_{ts}$ not in $PendingDequeues$}
        \State $PendingDequeues.insertByTs(createList(Deq_{ts}, p_{invoker}))$
      \EndIf
      \For{$confirmationList$ in $PendingDequeues$}
        \If{$confirmationList.ts ==  Deq_{ts}$}
          \If{$\textit{Unsafe}$}
            \State $response = 2$
          \Else
            \State $response = 1$
          \EndIf
          \State $confirmationList.list[j] = response$
        \EndIf
        \State $propagateEarlierResponses(PendingDequeues)$
      \EndFor

      \For{($index, confirmationList)$ in $PendingDequeues$}
        \If{not $confirmationList.contains(0)$ and not $confirmationList.handled$}
          \State $pos = 0$
          \For{$response$ in $confirmationList.list$}
            \If{$response == 2$}
              \State $pos += 1$
            \EndIf
          \EndFor
          \State $confirmationList.handled = True$
          \State $updateUnsafes(Lists, index)$
          \State $ret = localQueue.deqByIndex(pos)$
          \State $labelElements(p_{invoker})$
          \If{$i == p_{invoker}$}
            \State \Return $ret$
          \EndIf
        \EndIf \Comment{Not sure I left the nesting right on these.}  
      \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%
\subsection{Correctness}

%%%%%%%%%%%%%%%
\subsection{Complexity}

%%%%%%%%%%%%%%%
\section{Conclusion}

\bibliography{refs.bib}

\end{document}
o
